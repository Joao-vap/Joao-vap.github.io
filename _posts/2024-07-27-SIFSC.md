---
title: 'Who is checking my poster? Referees assignments in the SIFSC'
date: 2024-07-27
permalink: /posts/2024/07/CongressAttributions/
tags:
  - Medium
  - Congress
  - Computational
---

We don't talk enough about referees allocations for posters sections.

I’ve been to a few local and national congresses by now. A lot of them, by the way we are accustomed to presenting scientific work, have had a poster session or some similar version of this model. In any case, there is a time when attendees are expected to present their work to other participants, especially to a handful of referees who will evaluate the merits of the presentation. This was the case during the scientific week of the Physics Institute of São Carlos ([SIFSC](https://www.instagram.com/sifsc_usp/) - USP), the institute where I graduated. The event is called Integrated Physics Week of São Carlos SIFSC, and it is mainly organized by the students of the institute, a mix of undergrads, masters, and PhD students. In my first year as an organizer, I was part of the team in charge of systems and evaluations, which is responsible, among other things, for the poster section. That mainly means managing the entries of referees and participants, allocating to each of the latter a few of the former and a section of time to present their work.

This all sounded normal enough for me. After all, I am well aware that many events do the same thing. The first shock came when I was informed that this task was previously performed by hand by someone (most likely a saint) in the administration. This is a Herculian task. To do that, you would have to know, or research, all of the referees and have a basic idea of their research. Then you would have to read participants research and try to match them with referees. However, that would still be simpler than it usually is. You have a limited number of participants you can fit in each section, meaning a couple poster sections. Naturally, participants and referees will have time constraints, something you may want to consider. Of course, you wouldn’t want to allocate a referee to multiple sections throughout the whole event, nor would you want to allocate lots of participants in the same section to the same referee. That would make the referee’s job almost impossible and the evaluation poorer. Bear in mind that some referees will have less in common with participants than the average, and you can’t afford to not allocate them to some students. If you’re organizing a local event and have some kind of award, you may also want to guarantee that the referees are not evaluating their own students or someone too close to their laboratory. If doctoral students are being evaluated, you may want to avoid their evaluation of master students and, of course, of other doctoral students. The same goes for master students, which is more uncommon but still possible if short on referees. Not only that, but you have to reallocate participants constantly to accommodate referees that drop out or have some kind of unforeseen event.

This is to say: It is necessary to have an algorithm to deal with most of this. This is the problem we try to solve in this post. Many of the implementations are still being tested but have shown to facilitate the task very much. Knowing all of this, I’m actually very impressed with the organization of most events I’ve been to. Either they know something I don't, or this is the fruit of a lot of sweat on their part. Either way, I’m sure many of the ideas can be used by someone trying to overcome a similar problem.


Approaching the problem
==========

We have many problems to solve to get to the final allocation. I will briefly describe the ideas we use to get a solution and in the next section explain how to implement it (in a somehow general manner). You can alternatively access the code used in [Allocation](/files/posts/SIFSC/TestAllocation.ipynb).

1. **Correlation of Participant-Referee**: We will to create a correlation matrix that give us how much a referee is related to a participants profile. This matrix is one of the main ideas of the algorithm but it is also easy to implement, given the correct dataset to work with. We will collect, from anyone registering, a list of words related to their research and then use a SVD approach to project them in a lower dimension. In this dimension, it is easier to define a distance between the vectors that represent participants and referees. This is how we build the correlation matrix.

2. **Allocation Matrix**: We need to create a matrix, which we will call matrix of allocation, where each line is a participant and each column is a referee. If the participant is allocated to be evaluated by a referee, the cell in the crossing of the collumn and line has value 1, otherwise it is valued 0. We also need to impose some rules to the allocation, as discussed. This can be, for example, being a doctoral student and not being evaluated by a doctoral student or a referee not evaluting its own supervised students. This matrix of rules is used as a mask to create the allocation matrix. The allocation matrix will also have, however, to obbey some general rules we impose, those are:
    1. Each student must have a defined number of referees (each line must have a defined number of 1's and be zero elsewhere)
    2. Each teacher must have around the same defined number of students (each column must have about a defined number of 1's and be zero elsewhere)
    3. The rules matrix must be respected (each 0 in the matrix of rules must be 0 in the allocation matrix)

3. **Optimize Allocations and Section**: Suposse we have a plausible allocation matrix. In order to have better evaluations and, overall experience, we should make sure it is optimized. The parameter to which we optimize it is a score function that evaluates the quality of the allocation. The optimization of this function shouold maximize the sum of allocated correlation of each participant and minimize its global variance. We also have to consider time constraints and the number of sections each referee has been located to. We will use a stochastic search to accomplish those goals. That is, we move randomly and use the gradient of the score function to generally guide the search.

4. **Reallocation of Participants**: We'll probably have to reallocate participants to accommodate referees that drop out or have some kind of unforeseen event. We also use the same ideal of a stochastic search to optimize this function, now bearing in mind that we should minimize interference with non-problematic allocatinons as to not cause confusion among other referees and participants.


Implementation
=======


Data fields
----------

We need to first think about what data we need from the participants and referees. The registering form must contain at least the following fields:

1. **Name**: The name of the participant or some identificator;
2. **Type**: The type of participant (student or referee);
3. **Research**: A list of words, fields or concepts from wich a subset related to the research of the participant/referee can be chosen;
4. **Class**: 
    1. **Class of referee**: If the participant is a referee, the type of referee (professor, researcher or phd student);
    2. **Class of student**: If the participant is a student, the type of student (phd, master or undergrad);

Those are the main fields. Here, beacuse of the nature of our event, we consider that some participants don't wish to run for the award. Furthermore, we also wish to avoid conflits of evaluation and time constraints, therefore we will add the following fields:

5. **Supervised**: If the participant is a referee, a list of students supervised by him. If we wish to cross check, the students must also have a list of referees that supervise them;
6. **Pypm**: If the participant is a student, if he is running for the award (called here Pypm);
7. **Time Restrictions**: If the participant is a referee, the time he is available to be in a section. You can also allow for the participant to disclaim his preference for a section;


Configurations for simulation
------------------

In this post however, and in the code provided, we won't use the data provided from participants. Therefore we have to simulate our own data. Let's define our simulated event. The fields marked as 'Simulated' are to be dismissed when using real data. 


| Field | Description | Value | Simulated |
| --- | --- | --- | --- |
| NStudents | Number of Students| 250 | No |
| NReferees | Number of Referees | 100 | No |
| Words | Number of words to choose from | 30  | No |
| Avl/Std | Number of referees for each student | 3 | No |
| Avl/Ref | Number of participants for each referee | ~250//(100*3) | No |
| Groups | Number of theoretical groups participants belong to | 5 | Yes |
| Noise | How likely to choose word from other group (1 is most) | 0.1 | Yes |
| Related | How likely to choose word from own group (1 is most) | 0.9 | Yes |
| Rel | Number of total orientations | 100 | Yes |
| PropStd | Proportion of each class of students (phd, master, undergrad) | (1,1,1) | Yes |
| PropRef | Proportion of each class of referees (professor, researcher, phd student) | (1,1,1) |  Yes |
| NSections | Number of poster sections | 4 | No |
| Std/Sec | Number of students per section | ~250//4 | No |

We can of course change this parameter as we see fit for our own event specifications. Either way, the objects Referee and Students will be instantiated and, from then on, all processes are the same.


Creating the Correlations
========

We now need to create a correlation matrix that will relate Referees to Students. 

A simple approach: SVD
---

Singular Value Decomposition, SVD, is a mathematical tool that gives us a matrix decomposition for a matrix \\(A_{m,n}\\) symmetric and semi-definite positive. We say that

$$
A = U \Sigma V^T
$$

where we say \\(U\\) to be a collumn matrix of eigenvectors of \\(AA^T\\) and \\(V\\) a collumn matrix of eigenvectors of \\(A^TA\\). The matrix \\(\Sigma = \Lambda^{1/2}\\) is diagonal with \\(\Lambda\\) being diagonal of eigenvalues of \\(AA^T\\) and \\(A^TA\\). How to interpret it and why is it important? We can think of the transformation as the following scheme

$$
\mathbf{y}=\mathbf{A}\mathbf{x}=(\underbrace{\mathbf{U}(\overbrace{\Sigma(\underbrace{\mathbf{V}^\top\mathbf{x}}_{\text{projection}}}^{\text{scale}}))}_{reconstruction})
$$

that is,

- $$\mathbf{V}^\top\mathbf{x}$$: Projection of vector $$\mathbf{x}$$ in the basis $$\mathbf{v}_i$$.

$$
\begin{bmatrix}
\mathbf{v}_1^\top\mathbf{x} \\ \vdots \\ \mathbf{v}_n^\top\mathbf{x}
\end{bmatrix}=
\begin{bmatrix}
- & \mathbf{v}_1 & - \\
 & \vdots & \\
- & \mathbf{v}_n & - 
\end{bmatrix}
\begin{bmatrix}
x_1 \\ \vdots \\ x_n
\end{bmatrix}
$$


- $$\mathbf{\Sigma}\mathbf{V}^\top\mathbf{x}$$:
Scales each coefficient by $$\sqrt{\lambda_i}$$

$$
\begin{bmatrix}
\sqrt{\lambda_1}\mathbf{v}_1^\top\mathbf{x} \\ \vdots \\ \sqrt{\lambda_n}\mathbf{v}_n^\top\mathbf{x}
\end{bmatrix}=
\begin{bmatrix}
\sqrt{\lambda_1} & \cdots & 0 \\
 &  \ddots & \\
 0 &  \cdots & \sqrt{\lambda_n}\\
\end{bmatrix}
\begin{bmatrix}
\mathbf{v}_1^\top\mathbf{x} \\ \vdots \\ \mathbf{v}_n^\top\mathbf{x}
\end{bmatrix}
$$

- $$\mathbf{U}\mathbf{\Sigma}\mathbf{V}^\top\mathbf{x}$$: $$\mathbf{y}$$ is linear combination of $$\mathbf{u}_i$$ with coefficients $$\sqrt{\lambda_i}\mathbf{v}_i^\top\mathbf{x}$$

$$
\mathbf{y}=(\sqrt{\lambda_1}\mathbf{v}_1^\top\mathbf{x})
\begin{bmatrix}
| \\ \mathbf{u}_1 \\ |
\end{bmatrix}+\cdots+
(\sqrt{\lambda_n}\mathbf{v}_n^\top\mathbf{x})
\begin{bmatrix}
| \\ \mathbf{u}_n \\ |
\end{bmatrix}
$$

The big advantage of using this method is that we can reduce the dimensionality using a truncated version of the SVD. If we rank the eigenvalues and choose th most relevant dimensions we can work on a simpler problem with few dimension. It is possible indeed to show that this reduced matrix is in fact the best approximation for the original matrix. In our case, each dimension will be a linear combination of words such that each direction better describe the data. In that way, dimensions can be interpret as research groups in the data.

How to apply te SVD
---------------

We use the words collected from the participants and referees to create what we call a matrix of words. Every collum in our data must be a word and every line a participant. The same must be done for the referees. Now that we have a vector representation for each  (lines of 0's and 1's), we perform the SVD decomposition in the students matrix. That is, we will get from \\( M_s \\), matrix of words from sudents, the following

$$
M_s = U \Sigma V^T
$$

where we will actually work with the reduced form

$$
M_{sr} = U_r \Sigma_r V_r^T
$$

with \\( r \\) being the number of dimensions we will keep. Now, as we know that the directions that better describe our data are the collumns of \\( U_r \\), we can project both the referees and students in this new space. It is now only missing to define a distance between vectors. This can be simply the dot product of the vectors. The closer to 1, the more similar the vectors are - the closer to -1, the more different they are. We can now create a matrix of correlation between referees and students. This matrix, colored green when close to 1 and red when closer to -1, will look something like this

<p style="text-align:center">
<a href="/files/posts/SIFSC/Corr.html">
<img src="/images/posts/SIFSC/Correlations.jpg" alt="SIFSC Corrrelation Matrix"
  title="SIFSC Corrrelation Matrix" style="width: 100%; margin=10px;"/>
</a>
</p>

Notice that I've clustered students and referees from the same group to be easier to visualize the correlation inside groups. This matrix will help us to determine who to pair up.

Allocations
========

We will first try to generate a possible solution for the problem, not necessarily a good one. The general rules we must follow for the allocation are

1. Each student must have a defined number of referees (each line must have a defined number of 1's and be zero elsewhere);
2. Each teacher must have the between a defined number of students and this number +1 (each column must have about a defined number of 1's and be zero elsewhere);
3. The matrix of rules must be respected (each 1 in the rulesMatrix must be 0 in the allocation matrix)

Rules and initial condition
-------------------------

What is the rules matrix? As we said before, we ma want to inforce whichever rules we see fit for the allocation. In this case, we will make so that doctoral students can't evaluate other doctoral students and referees can't supervise the students he evaluates. This will generate a matrix with ones where a allocation can't happen and zero otherwise. Just like the following matrix, colored red for zero and green for one.

<p style="text-align:center">
<a href="/files/posts/SIFSC/RulesMatrix.html">
<img src="/images/posts/SIFSC/Rules.png" alt="SIFSC Rules Matrix"
  title="SIFSC Rules Matrix" style="width: 100%; margin=10px;"/>
</a>
</p>

Every time we try to perform an allocation, this matrix must be checked. In this way we can impose any arbitrary rule.

We're now missing an algorithm to get a possible configuration of the allocation matrix. Some problems can arise here if not enough referees are avaiable, especially when the rules for allocations are strict. If that's the case, we need to increase the possible number of evaluations per referee or soften the rules. Assuming everything will go smoothly, we first try to allocate the referees to the students who have more restrictions, such as the doctoral students (can only the evaluated by teachers or researchers). This is because if we don't, we may allocate too much of researches and teachers for undergraduates and miss those for the doctoral students. Depending on the situation you are working with, you may want to have different cicles such as the one described. 

For each of these cicles - here, one for doctoral and one general for the yet non-allocated - we do the following. For each student, get every possible referee (noting the rules) and sort them for: The number of students they already have allocated and the correlation with the student, in this order. Now, allocate as many referees as needed to the student in the sorted order. If there is no referee to allocate, skip the student and change the settings or deal with that in the end. Keep going for the rest of students in the cycle and then, do the same in all other cycles. Hopefully, this will generate a possible configuration for the allocation matrix.

<p style="text-align:center">
<a href="/files/posts/SIFSC/AllocMatrix.html">
<img src="/images/posts/SIFSC/InitialAlocation.png" alt="SIFSC Allocation Matrix"
  title="SIFSC Allocation Matrix" style="width: 100%; margin=10px;"/>
</a>
</p>

Improving the condition
------------------

We need to improve the allocation. How do we define 'best' in this scenario? We first need a function that associates each configuration of possible allocation matrix to a scalar. The bigger the scalar, the better we will consider the matrix to be - and equivalently the allocation. This can be, given the goals in mind, any arbitrary function. We will use the following evaluation

```python
#@title Function Score
def scoreMatrix(vec):
    # parameter of the score
    alpha = 3
    beta = 5
    idealVector = np.array([3 for _ in range(nStd)]) / np.linalg.norm(np.array([3 for _ in range(nStd)]))

    # calcute the variance of the score
    var = np.var(vec)

    # normalize the vector
    vec = vec / np.linalg.norm(vec)
    # calculate the dot product with the vector of 3's
    dot = np.dot(vec, idealVector)

    # calculate the score
    score = alpha*var - beta*dot

    return score, var, dot
```

The idea is to create a vector with the sum of the allocated correlations of each student as entries. We then define the distance of this vectors to an ideal vector. This can be, for example, a vector full of the max sum possible - m, if there is m allocations. The other metric we consider is to minimize the variance of the sum of the allocated correlations. We don't want students to have largely different 'quality' of evaluations. Those two metrics can be weighted as we wish for different results.

We now want to swap students between referees if that improves the allocation score. This can be exausthing to perform by hand, of course. Therefore, we implement an estochastic algorithm. The idea is very much insired by spin simulations, that is, Monte Carlo simulations. We perform a random swap and check how the new score \\(S_f\\) changes in relation to \\(S_i\\). If the score improves, this swap is done with probabiliy one. Otherwise, we perform the swap with probability

$$
p = f(S_f)/f(S_i).
$$

It is usual in physics simulations for this function \\(f\\) to be an exponential. We can, however, change it to better fit our purpose and score function. The great difficulty of this algorithm is usually that it can get stuck in local minima. To conter that effect, we should allow for non-optimal steps with a reasonable probability. We also, instead of proposing the change of state step by step, can propose a couple of steps together, to allow for larger exploration in each proposition. All this parameters are highly personal to each situation and must be tinkered with.

A reasonable thing to do is to guide the random steps. This is equivalent to a Hamiltonian approach to Monte Carlo methods. If you wish, you can random select the possible steps with weights proportional to some measure, for example, correlation with the student. This is also done in our simulation.

<p style="text-align:center">
  <img src="/images/posts/SIFSC/dotproduct_iteration.png" width="40%" />
  <img src="/images/posts/SIFSC/variance_iteration.png" width="40%" />
  <img src="/images/posts/SIFSC/score_iteration.png" width="40%" />
</p>


The meaning of these graphs are direct. The dot product is the correlation of the sum of the allocated correlations of students with an 'ideal vector'. The variance is the variance of the sum of the allocated correlations of the students. The score is the score function we defined before. We can see in the first graph that the dot product is increasing; in the second that the variance is decreasing and in the third that the score is decreasing. This is a good sign that the algorithm is working. Note that here, the score is negative because of the definition. The more negative, the better the allocation. We get a new allocation matrix that looks like

<p style="text-align:center">
<a href="/files/posts/SIFSC/SellectedMatrixBest.html">
<img src="/images/posts/SIFSC/SellectedAlloc.png" alt="SIFSC Best Allocation Matrix"
  title="SIFSC Best Allocation Matrix" style="width: 100%; margin=10px;"/>
</a>    
</p>

Notice that allocations gather around the groups areas. The score function, parameters and running time will radically change results. If sections didn't matter, this would be the whole algorithm. If we study the distribution of allocated correlations we get something like

<p style="text-align:center">
<img src="/images/posts/SIFSC/correlationdist.png" alt="SIFSC Best Allocation Dist"
  title="SIFSC Best Allocation Dist" style="width: 60%; margin=10px;"/>   
</p>

However, we go further.

Time allocations
===============

To go further we now try to associate students with poster sections. Our main interests in doing so is to garantee that

1. Every session has, at most, some number of students arbitrated by the venue size. If we can, it is good to keep sessions with more or less the same amount of people presenting;
2. Guarantee that every student has a single session and that referees have the minimun amount of sessions as possible. Bear in mind that too many allocation in one section can be a bad thing;
3. Acomodate possible time restrictions from students but mainly from referees.

We perform here a similar process as we did in the allocation scheme. We will first create a matrix similar to the allocation matrix but with time sessions instead of ones. The cells tahn can take any value in the range of 0 to n, with n being the number of sections and zero a non-allocation. To create a possible configuration is simpler here as we don't have many rules except for the limitations we may want to accomodate. For the restrictions, we again use a rules matrix, now with restricted sessions instead of ones. If we have our first possible matrix of poster session allocations, we need to improve it by the parameters we set before. This will be done using again: A score function to associate each configuration with a scalar and a estochastic algorithm to improve it.

However, some details are worth mentioning. The way we're doing the swaps is the following: We first select a referees randomly with probability based on how many sessions they have to attend (the more sessions, the more likely). Then, we need to select the student to swap. This can be done in the following manner: Select the section time based on how many students of the referee are allocated in each (the less the better - also look for students allocated alone in a section) and then, from this section, select one of the allocated students. Now we neeed someone to swap with. We look for a student in the main (if not full of students) section of the first referee - better if in a low frequency section of someome else - and especially good if with good correlation. One of the things we can make sure is that no one has to be in above a certain number of sections. This is done be tinkering the score function and penalizing a lot giving referees more sections than that. The implementation is a bit involved but the idea is simple. We try to swap students with like-correlated students in better sessions mutually. The progress is, again, guided with the evaluation of the score function. 

In doing so, we can get results like the following for the number of sections a referee has to attend

| Number of sections | Before Optimization | After Optimization |
| --- | --- | --- |
| 0 | 0 | 0 |
| 1 | 0 | 3 |
| 2 | 0 | 56 |
| 3 | 0 | 41 |
| 4 | 100 | 0 |

without a major change to the quality of the allocation.

A bit of improvement
------------------

This can be a tricky part. A nice work around the hard parts in this section would be to integrate the main allocation with the poster section allocation. In this manner we gain a little more flexibility. This won't, however, be discussed as it would be more of a implementation issue.


Final process: The emails arrive
===================

You will, very surely, get e-mails from students and referees saying that some allocation or poster section won't work for them for some reason. By personal experience the registration is not always well done and information may be mixed up. Now you have a problem at your hands: To reallocate arbitrary students to a suited different poster section or referee. You can of course rerun the algorithm. However this will create chaos. Reassigning all students is a sure way to create a huge mess. Be sure to create a like-minded algorithm as the ones we implemented that will create the minimum of changes as possible to the previous allocations.

A possible way to deal with this is to only reallocate the students who have some problem, not changing others. This means ignoring number of allocations per referee and adding those students as needed. This is tipically a easier way to solve the problem. Otherwise you will need to perform multiple swaps and weight in the score function the fact that you made a change to a previous allocation. This is a bit more involved but can also be done.